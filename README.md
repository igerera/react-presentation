React и другие библиотеки
===

React — библиотека, решающая очень узкую задачу: создание и обновление DOM дерева приложения. При этом она не имеет встроенных решений других задач приложения, таких как получение данных, обработка событий, и не накладывает никаких ограничений на их реализацию. Поэтому React подходит для использования в любых приложениях. Его можно встроить в приложения, использующие другие библиотеки, и другие библиотеки можно встроить в React-приложения.

На занятии мы рассмотрим наиболее интересные варианты использования: интеграция с интерактивными картами, с библиотекой jQuery, с готовым решением для фотогалерей Фоторама и с чистым DOM API. На этих примерах мы разберем общий подход к интеграции приложения с библиотекой React.

## Замена рендеринга, основанного на строках, на React-компонент

Начнём с самого распространенного случая, когда часть данных для веб-страницы мы получаем асинхронно, например в формате JSON, и эти данные нам нужно представить на странице.

### Задача

У нас есть сайт, на котором в одном из блоков показываются последние фотографии из Instagram:

```js
function fetchPhotos() {
  // …
}

fetchPhotos().then(images => {
  const body = images
    .map(image => `<img src="${image.url}" />`)
    .join(' ');
  document.querySelector('.instagram').innerHTML = body;
})
```

Функция `fetchPhotos` запрашивает фотографии из API и возвращает промис с массивом этих фотографий. Далее мы формируем html-структуру этого блока в виде простой строки. И помещаем её в тело тега с классом `instagram`.

В планах у нас полностью перевести сайт на React. Но мы можем делать это маленькими шагами. Так как этот блок независимый, то мы можем начать с него, создав React-компонент. Но как нам поместить этот компонент на страницу?

### Теория

Ответ на этот вопрос нам известен ещё с первого занятия. В библиотеке `ReactDOM` есть функция `render`, которая позволяет поместить компонент или JSX в конкретный DOM-узел страницы. В рамках курса мы в основном создавали приложения, которые целиком контролируют DOM-дерево страницы. Но ничто не мешает нам поместить созданный нами компонент не в корневой узел, а например, в какой-то более глубокий, например, в блок с классом `intagram`. При этом остальная часть дерева может контролироваться другими библиотеками.

### Решение

Для этого нам нужно получить нужный узел и передать его в функцию `render`:

```jsx
const node = document.querySelector('.instagram');
ReactDOM.render(<Intagram />, node);
```

Остаётся создать сам компонент `Intagram`:

```jsx
class Intagram extends React.Component {
  constructor(props) {
    super(props);
    this.state = { images: [] };
  }

  componentWillMount() {
    fetchPhotos.then(images => this.setState({ images }));
  }

  renderImage(image) {
    return <img src={image.url} key={image.id} />
  }

  render() {
    const { images } = this.state;
    return (
      <div>
        {images.map(this.renderImage}
      </div>
    );
  }
}
```

**Вопрос**: Почему мы добавили изображению атрибут `key`?

> Потому что мы генерируем список узлов, и чтобы React оптимально мог сравнивать их мы добавляем уникальный ключ, который не изменится при сортировке списка и при добавлении или удалении узлов.

В текущей задаче преимущество React-компонента не очевидно. Но давайте подумаем о перспективах. Так как теперь у нас полноценный React-компонент, то мы можем:

+ реализовать ручное обновление фотографий с помощью кнопки «обновить»
+ или реализовать автоматическое обновление по таймеру
+ добавить прелоадер для блока на время, пока изображения загружаются
+ сделать компонент более универсальным и повторно использовать, задавая имя пользователя Instagram через `props`.

При этом мы описываем только логику работы компонента и как должен формироваться DOM. А всю оптимизацию и безопасность берёт на себя React.

**Вопрос**: Почему использование `innerHTML` считается небезопасным?

> Установка `innerHTML` из кода имеет риск быть подверженным XSS атакам, когда в пользовательский контент внедряются скрипты и другие элементы, которые могут привести к потере данных пользователя, распространению вредоносного программного обеспечения.

### Добивка

Функцию `render` можно вызывать многократно, добавляя компоненты в разные узлы DOM-дерева:

```jsx
const nikestagram = document.querySelector('.nikestagram');
ReactDOM.render(<Intagram user="nike" />, nikestagram);

const nikewomenstagram = document.querySelector('.nikewomenstagram');
ReactDOM.render(<Intagram user="nikewomen" />, nikewomenstagram);

const cart = document.querySelector('.cart');
ReactDOM.render(<Cart />, cart);

const user = document.querySelector('.user');
ReactDOM.render(<Profile />, user);
```

Таким образом мы можем постепенно переводить отдельные элементы страницы на React.

## Интеграция с внешней галереей

Иногда бывают и обратные ситуации: интерфейс уже реализован на React, но мы хотим использовать готовое решение, которое реализовано не на React.

### Задача

Представим, что у нас есть React-приложение, в котором реализован личный кабинет пользователя. К следующему релизу необходимо добавить туда возможность просматривать все фотографии, которые относятся к пользователю. Из-за сроков было принято решение воспользоваться готовым решением [Fotorama](http://fotorama.io/).

Фоторама использует уже созданные узлы DOM-дерева, для создания поверх них фотогалереи, добавляя дополнительные узлы для управления.

### Проблема

Как интегрировать готовое решение, работающее с DOM, реализованное без использование React в приложение на React?

### Теория

Вспомним, что React — библиотека, которая берет на себя только задачу управления DOM-деревом документа. А точнее поддеревьями конкретных узлов. При этом не накладывает особых ограничений на их дальнейшее использование.

Поэтому мы можем обернуть библиотеку Fotorama в React-компонент, который создаст необходимые DOM-узлы для фотографий, а дальше библиотека сделает своё дело. Использовать этот компонент мы сможем например так:

```jsx
<Fotorama images={photos} />
```

### Решение

Создадим функциональный компонент:

```jsx
const Fotorama = ({ images }) => (
  <div className="fotorama">
    {images.map(image => (
      <img src={image.src} key={image.id} />
    ))}
  </div>
);
```

Наш компонент принимает массив изображений и создает для каждого тег `<img />`.

Следуя документации, контейнер должен содержать класс `fotorama`, поэтому мы так же добавили его в `<div />` который возвращает наш компонент. Остаётся добавить добавить следующие теги:

```html
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<link href="http://cdnjs.cloudflare.com/ajax/libs/fotorama/4.6.4/fotorama.css" rel="stylesheet">
<script src="http://cdnjs.cloudflare.com/ajax/libs/fotorama/4.6.4/fotorama.js"></script>
```

Мы выполнили все шаги из документации к библиотеке, но не получили ожидаемого результата: изображения создаются, но Fotorama не создаёт галлерею поверх них.

**Вопрос**: Может быть, у кого-то из вас есть предположение почему галерея не работает?

> Библиотека Fotorama так устроена, что в момент загрузки страницы она находит все контейнеры с классом `fotorama` и инициализирует фотогалерею в них. Но наш компонент `Fotorama`, видимо, создал узлы чуть позже, и поэтому в момент инициализации они ещё не были доступны.

### Добивка

Мы сможем исправить работу галереи далее. Но этот пример позволил нам сделать один из главных выводов интеграции в React других библиотек, работающих с DOM: инициализировать эти библиотеки необходимо после того, как компонент сформирует своё DOM-поддерево.

**Вопрос**: Как можно выполнить какой-то код, после того как поддерево DOM компонента будет готово и доступно в документе?

> Для этого у каждого компонента есть методы жизненного цикла этого компонента.

Когда дерево DOM компонентов готово и доступно документе, в компоненте вызывается метод `componentDidMount`. Выходит, что для таких компонентов нам не подойдут функциональные компоненты. Мы будем использовать компоненты, реализованные на основе классов.

## Добавление интерактивной карты в React-приложение

Отвлечемся немного от фотогалереи, но попробуем учесть полученный опыт при реализации компонента интерактивной карты.

### Задача

Очень часто в разделе «Контакты» отображается адрес компании. Еще иногда дизайнер рисует схему проезда. Но если дизайнер не картограф, то пользы от такой схемы клиентам будет немного. Поэтому часто вместо схемы помещают блок картой Google или Яндекс, на которой указывают точку где расположен офис.

Давайте попробуем решить эту задачу, создав компонент который будет добавлять на страницу Яндекс-карту. Сам компонент мы будем использовать примерно вот так:
```jsx
<Map center={[55.76, 37.64]} zoom={10} />
```

Мы планируем передавать в компонент два атрибута:
* `center` — это координаты точки в которой расположен офис, чтобы, если вдруг компания переедет (так часто бывает), мы смогли его поменять, не меняя сам компонент,
* `zoom` — исходный масштаб карты, чтобы мы могли показывать более детализированную карту района или менее подробную карту города, и опять же не менять сам компонент при этих экспериментах.

### Теория

В данной задаче интеграция неизбежна, потому что в отличии от фотогалереи, нет возможности создать компонент карты полностью на React. И нам потребуются метод `componentDidMount` жизненного цикла для инициализации карты после того как его контейнер будет помещен в DOM-дерево документа. Поэтому мы будем создавать компонент на основе класса.

### Решение

Начнем с подключения библиотеки карты. Она дает доступ к глобальной переменной `ymaps`.

```html
<script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU" type="text/javascript"></script>
```

Реализуем простой компонент, который создаст и вернёт контейнер для карты:

```jsx
class Map extends React.Component {
  render() {
    return (
      <div id="map"></div>
    );
  }
}
```

Добавим инициализацию карты в методе `componentDidMount`:

```js
componentDidMount() {
  const { center, zoom } = this.props;
  ymaps.ready(() => {
    this.map = new ymaps.Map('map', {
      center,
      zoom
    });
  });
}
```

Тут мы инициализируем карту, вызвав метод библиотеки `ymaps.Map`, передав следующие аргументы:
* идентификатор контейнера — `'map'`, в который поместить карту. Мы добавили атрибут `id` с таким же текстом контейнеру.
* объект со свойствами карты, указав свойства `zoom` — масштаб, и `center` — где будет центр карты, берем его из атрибутов компонента `this.props.center`.

Присваем результат свойству объекта `map`. Возможно нам потом потребуется доступ к объекту карты в других методах компонента. Теперь компонент отображается и решает поставленные задачи.

### Добивка

**Вопрос**: Как поведет себя компонент, если при очередном ререндере его `props` обновятся?

> Ничего не изменится, так как в этом случае дерево DOM компонента не поменяется, и метод `componentDidMount` не будет вызван.

Для того чтобы исправить эту проблему вам необходимо реализовать метод `componentWillReceiveProps`, в котором обновить или пересоздать карту, если свойства поменялись:
```js
componentWillReceiveProps(newProps) {
  const { center, zoom } = this.props;
  if (newProps.center !== center || newProps.zoom !== zoom) {
    this.map.setCenter(newProps.center, newProps.zoom);
  }
}
```

Вот нам и пригодился объект карты, который мы поместили в свойство `map` в методе `componentDidMount`. И мы воспользовались методом `setCenter` ([документация](https://tech.yandex.ru/maps/doc/jsapi/2.1/ref/reference/Map-docpage/#setCenter)), чтобы установить новый центр карты и новый масштаб, если что-то из них изменилось.

Ещё правилом хорошего тона является обязательная «уборка» за собой внутри подобного компонента. Добавим метод `componentWillUnmount` в котором уничтожим карту методом `destroy` ([документация](https://tech.yandex.ru/maps/doc/jsapi/2.1/ref/reference/Map-docpage/#destroy)) из библиотеки:

```js
componentWillUnmount() {
  this.map.destroy();
}
```

Стоит отметить, что нет необходимости оборачивать создание карты в функцию `ymaps.ready()`, что мы делаем в `componentDidMount`. Мы взяли его из примера в документации, но если прочитать документацию более внимательно:

> Создавать карту следует после того, как веб-страница загрузится целиком. Это даст уверенность в том, что контейнер для карты создан и к нему можно обращаться по `id`. Чтобы инициализировать карту после загрузки страницы, можно воспользоваться функцией `ready()`.

Очевидно, что компонент начинает монтироваться только после полной загрузки страницы, а `componentDidMount` выполняется, когда компонент смонтирован, и к нему можно обращаться. Поэтому можно отказаться от `ymaps.ready()` в `componentDidMount`:

```js
componentDidMount() {
  const { center, zoom } = this.props;
  this.map = new ymaps.Map('map', {
    center,
    zoom
  });
}
```

**Вопрос**: Сколько можно поместить карт с помощью этого компонента на страницу? Почему?

> С помощью данного компонент можно поместить на страницу только одну карту, потому что в коде компонента зашит `id` контейнера карты. И если поместить второй компонент, он просто инициализруется в узел первого. Ну и возможны другие конфликты.

## Несколько карт на странице

Мы решили частную задачу, но создали компонент, который имеет потенциальные проблемы в использовании. В программировании в целом и в React в частности такие проблемы — как бомба замедленного действия. Поэтому нужно стараться их избегать, создавая максимально независимый код.

### Задача

Доработать компонент `Map`, чтобы иметь возможность добавлять на страницу несколько карт:

```jsx
<Map center={[55.76, 37.64]} zoom={10} />
<Map center={[53.21, 24.31]} zoom={12} />
<Map center={[61.55, 40.18]} zoom={8} />
```

### Теория

`id` должны быть уникальными для каждого элемента на странице, не должно быть повторений. Например, мы можем просто добавить возможность передать `id` через `props`. Но этим решением мы просто перекладываем ответственность на пользователя компонента, а не решаем проблему. Обратимся к документации конструктора `ymaps.Map`:

> Тип: Object|String. Ссылка на HTML-элемент, в котором размещается карта или идентификатор этого HTML-элемента.

Получается, что вместо строки идентификатора, мы можем передать сам элемент.

Для того чтобы получить ссылку на элемент контейнера карты в React, воспользуемся свойством `ref`, которое мы ранее использовали для форм.

### Решение

Перепишем метод `render`, убрав атрибут `id` и добавив `ref`, в котором поместим ссылку на DOM-элемент в свойство `node` компонента:

```jsx
render() {
  return (
    <div ref={node => this.node = node}></div>
  );
}
```

Теперь перепишем инциализацию карты, передав в `ymaps.Map` вместо строки `'map'` ссылку на элемент из `this.node`:

```js
componentDidMount() {
  const { center, zoom } = this.props;
  this.map = new ymaps.Map(this.node, {
    center,
    zoom
  });
}
```

Убедимся что после этих изменений всё работает так же. И попробуем теперь создать несколько карт, убедившись что каждая из них действует независимо без каких либо конфликтов.

### Добивка

Компоненты React подчиняются тем же правилам, что и обычные html-элементы. В том числе правилу уникальности идентификаторов.

Сейчас мы выявили еще один важный принцип интеграции: использовать `ref` вместо косвенной адресации по `id` или `class` внутри компонента. Таким образом мы повышаем независимость компонентов и снижаем риск возможных конфликтов.

## Интеграция с jQuery-плагином Chosen

Попробуем применить уже опробованные принципы интеграции, применив их для интеграции в React приложения библиотеки jQuery.

### Задача

Существует интернет-магазин одежды, интерфейс которого полностью построен с использованием библиотеки jQuery. В компании планируется переход на React, но разом переписать весь код невозможно, это слишком дорого.

Сейчас выбор размера на странице товара реализован при помощи jQuery-плагина [Chosen](https://harvesthq.github.io/chosen/). Требуется написать обертку для этого плагина на React.

> Chosen — плагин для создания более дружественных к пользователю полей выбора.

Сейчас поле выбора инициализируется вот так:
```html
<select class="enhance">
  <option>S</option>
  <option>M</option>
  <option>L</option>
</select>
```

```js
$('select.enhance').chosen();
```

Мы хотим чтобы все задачи по организации поля выбора решались в React-компоненте:
```jsx
<Chosen>
  <option>S</option>
  <option>M</option>
  <option>L</option>
</Chosen>
```

### Теория

Мы можем получить внутри React-компонента ссылку на реальные узлы, созданные в методе `render()` и помещенные в DOM-дерево документа через свойство `ref`, после чего и манипулировать DOM-элементом через jQuery.

### Решение

Создадим класс компонента и метод `render`:
```jsx
class Chosen extends React.Component {
  render() {
    return (
      <div>
        <select ref={el => this.root = el}>
          {this.props.children}
        </select>
      </div>
    );
  }
}
```

Тут мы помещаем ссылку на `<select>` в свойство `node` компонента.

Остаётся инициализировать плагин и уничтожить при удалении компонента:

```js
componentDidMount() {
  this.$root = $(this.root);
  this.$root.chosen();
}

componentWillUnmount() {
  this.$root.chosen('destroy');
}
```

**Вопрос**: Что такое `this.root` в методе `componentDidMount`?

> Если вы внимательно следили за реализацией, то помните, что это узел соответствующий тегу `<select>` который мы получили с помощью `ref` в методе `render`:
> `<select ref={el => this.root = el}>…</select>`.

### Добивка

Если мы работаем с jQuery, то нам всегда нужно помнить об «оборачивании» обычных элементов в jQuery-элементы. Обернутые элементы ещё обычно хранят в переменных или свойствах с префиксом `$`.

В данном компоненте, чтобы не плодить свойства, в одном из которых сохранена ссылка на `<select>` — `this.root` а во втором эта же ссылка, но обернутая в jQuery — `this.$root`, можем обернуть узел сразу в ref-колбеке:

```diff
class Chosen extends React.Component {
  render() {
    return (
      <div>
-       <select ref={el => this.root = el}>
+       <select ref={el => this.$root = $(el)}>
          {this.props.children}
        </select>
      </div>
    );
  }

  componentDidMount() {
-   this.$root = $(this.root);
    this.$root.chosen();
  }

  componentWillUnmount() {
    this.$root.chosen('destroy');
  }
}
```

Сейчас изменение списка размеров не влияет на работу плагина. Если у нашего компонента меняются дочерние элементы, то DOM-дерево обновляется. Но плагин Chosen не видит этих изменений. Для того чтобы заставить его обновиться, нужно вызвать на элементе событие `chosen:update`. Лучше всего это сделать в методе жизненного цикла `componentDidUpdate`:

```js
componentDidUpdate(prevProps) {
  if (prevProps.children !== this.props.children) {
    this.$root.trigger('chosen:updated');
  }
}
```

## Исправление ошибки в компоненте Fotorama

Вернёмся к задаче фотогалереи. Давайте попробуем исправить наш компонент, чтобы он заработал. Ведь Fotorama по сути — это такой же jQuery-плагин как и Chosen.

### Задача

Напомню, мы реализовали компонент, который помещает фотографии на страницу, но фотогалерея из них не создается:

```jsx
const Fotorama = ({ images }) => (
  <div className="fotorama">
    {images.map(image => (
      <img src={image.src} key={image.id} />
    ))}
  </div>
);
```

Исправим это и «оживим» галерею.

### Теория

Элементы, создаваемые React, появляются в DOM-дереве не одновременно с обычными html-элементами. Когда весь документ загружен, React-компоненты только начинают рендерится. Потому, если они используются другими бибилиотеками, требуется инициализировать эти библиотеки явно в методе `componentDidMount` компонента.

Мы уже выясняли на примере карт подход к интеграции внешних библиотек в React: создаем DOM и инициализируем библиотеку в методе `componentDidMount`. Так же, мы знаем, что лучше вместо класса у тега использовать прямую ссылку на элемент.

Поэтому стратегия решения этой задачи состоит из следующих этапов:

1. Переделать функциональный компонент в полноценный компонент на основе класса.
1. Получить ссылку на элемент, сохранить её в свойство компонента
1. Инициализировать библиотеку Fotorama для этого элемента в методе `componentDidMount`

### Решение

Перепишем компонент таким образом, чтобы сохранить в нем ссылку на результирующий элемент. Сразу обернем её в jQuery объект:

```jsx
class Fotorama extends React.Component {
  render() {
    return (
      <div ref={el => this.$root = $(el)}>
        {images.map((image, index) => (
          <img src={image.src} key={index} />
        )}
      </div>
    );
  }
}
```

Согласно документации, на элементе следует вызвать метод `fotorama()`. Сделаем это после монтирования компонента:

```js
componentDidMount() {
  this.$root.fotorama();
}
```

А также не забываем удалить модуль при удалении компонента.

Вот и всё. Теперь фотогалерея работает.


### Добивка

Как видите, следуя простым принципам и внимательно изучая документацию библиотек, мы можем интегрировать с React практически любую библиотеку.

## Передача событий из jQuery

### Задача

Вернемся к нашему интернет-магазину и компоненту выбора размера, который оборачивает jQuery-плагин Chosen. Сейчас мы никак не можем обработать события выбора размера. Давайте доработаем компонент, чтобы мы могли обработать событие выбора и получить выбранное значение, примерно так:

```jsx
<Chosen onSelect={selectHandler}>
  <option>S</option>
  <option>M</option>
  <option>L</option>
</Chosen>
```

При этом `selectHandler` функция, которая принимает выбранный размер, и, например, выводит его в консоль:
```js
const selectHandler = size => console.log(`Выбран размер ${size}!`);
```

В реальном приложении мы можем передать более полезный обработчик, который, например, обновит фотографию товара, соответствующую выбранному размеру.

### Теория

Передавать обработчики событий в другие библиотеки или модули ничем не отличается от процесса передачи обработчиков в DOM. Стратегия реализации точно такая же:

1. Создаём метод в компоненте, который будет обрабатывать событие.
1. Не забываем позаботиться о контексте вызова этого метода.
1. Подписываем метод на событие или передаём в настройки компонента.

### Решение

Добавим в наш компонент метод `handleChange`, который будет вызываться при выборе одного из вариантов в плагине Chosen.

```js
handleChange(event) {
  const { onChange } = this.props;
  if (!onChange) {
    return;
  }
  onChange(event.target.value);
}
```

Чтобы не иметь в дальнейшем проблем с контекстом вызова этого метода, «забиндим» его в конструкторе:

```js
constructor(...args) {
  super(...args);

  this.handleChange = this.handleChange.bind(this);
}
```

Теперь просто повесим его на событие `change` нашего элемента. Так как мы уже используем jQuery, и у нас есть «обёрнутый» элемент, воспользуемся его методами `on` и `off`:

```js
componentDidMount() {
  this.$root.chosen();
  this.$root.on('change', this.handleChange);
}

componentWillUnmount() {
  this.$root.off('change', this.handleChange);
  this.$root.chosen('destroy');
}
```

### Добивка

Методы React-компонентов легко передавать как callback сторонним библиотекам и тем самым интегрировать их не только на уровне работы с DOM-деревом, но и на уровне обработки событий.

## Добавление на интерактивную карту точек

Вернёмся к нашему компоненту карты, добавим ему немного интерактива.

### Задача

Мы уже реализовали ранее компонент карты `Map`. С того момента компания расширилась, и у неё появилось несколько офисов. Поэтому требуется показать их все на карте. А также при клике на одну из точек иметь возможность обработать выбранную точку:

```jsx
<Map
  zoom={10}
  center={[55.76, 37.64]}
  points={offices}
  onPointSelect={handlePoint} />
```

Тут в переменной `offices` у нас хранится массив точек, например такой:
```js
const offices = [{
  center: [55.76, 37.64],
  title: 'Главный офис'
}, {
  center: [57.21, 36.90],
  title: 'Центральный склад'
}]
```

А функция `handlePoint` может выглядеть как-то так:
```js
const handlePoint = point => console.log(`Выбрана точка ${point.title}!`);
```

### Теория

Мы можем работать с сохраненным внутри компонента объектом карты как с любым другим. Вызывать его методы, которые определены во внешней библиотеке. Также мы можем методы компонента передавать в качестве обработчиков событий в объект карты или в её дочерние объекты.

### Решение

Начнём с реализации метода `handlePointClick`, который будет обрабатывать клик по точке на карте:
```js
handlePointClick(point) {
  const { onPointSelect } = this.props;
  if (!onPointSelect) {
    return;
  }
  onPointSelect(point);
}
```

Чтобы не иметь в дальнейшем проблем с контекстом вызова этого метода, «забиндим» его в конструкторе:

```js
constructor(...args) {
  super(...args);

  this.handlePointClick = this.handlePointClick.bind(this);
}
```

Документация к API описывает, чтобы добавить метки на карту достаточно просто создать их с помощью конструктора `ymaps.Placemark`, а потом добавить с помощью метода `add` в свойстве `geoObjects` карты. Реализуем это внутри метода `componentDidMount()`:

```js
componentDidMount() {
  const { center, zoom, points } = this.props;
  this.map = new ymaps.Map(this.node, {
    center: this.props.center,
    zoom: 10
  });

  const { geoObjects } = this.map;
  points.forEach(point => {
    const placemark = new ymaps.Placemark(point.center, {
      hintContent: point.title
    }, {
      hasBalloon: false
    });
    placemark.events.add('click', () => this.handlePointClick(point));
    geoObjects.add(placemark);
  });
}
```

Точки появились. При выборе выводится сообщение в консоль.

Если сравнить код решения с тем, что мы реализовали ранее для Chosen, то можно заметить, что отличия только в API самой интегрируемой библиотеки. В остальном реализация идентичная.

### Добивка

Кроме прочего, следите за тем, что свойствам компонента всегда можно задать значения по умолчанию, чтобы сделать их необязательными, и настроить `PropTypes`, чтобы с одной стороны сделать использование компонента более безопасным, а с другой — задокументировать его интерфейс.

Давайте настроим некоторые свойства для нашего компонента карты:
```js
Map.propTypes = {
  onPointSelect: PropTypes.func,

  zoom: PropTypes.number,
  center: PropTypes.arrayOf(PropTypes.number).isRequired,
  points: PropTypes.arrayOf(PropTypes.shape({
    center: PropTypes.arrayOf(PropTypes.number).isRequired,
    title: PropTypes.string
  })),
};

Map.defaultProps = {
  zoom: 10
};
```

## Выводы

React — весьма универсальная библиотека, которая может быть легко интегрирована в практически любое приложение. Для этого нужно следовать простым принципам:

1. Используйте для интеграции и обертывания компоненты на основе классов.
1. Используйте прямую ссылку на DOM-узлы, используя свойство `ref`, вместо поиска по идентификатору или классу.
1. Инициализируйте и обновляйте состояние стороннего плагина в методах жизненного цикла компонента `componentDidMount`, `componentDidUpdate`, `componentWillReceiveProps` и другие.
1. Передавайте методы компонента в качестве обработчика событий в плагин. Не забывайте о контексте вызова.
1. Не забывайте «прибрать» за собой, уничтожив всё, что создал плагин и все обработчики событий в методе `componentWillUnmount`.
1. Внимательно изучайте документацию библиотек, чтобы сделать интеграцию правильно.
1. Настраивайте для компонента значения свойств по умолчанию (`defaultProps`) и валидацию критичных свойств (`propTypes`).
